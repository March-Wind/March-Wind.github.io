---
title: nodejs 内存溢出
# subtitle: 没有方法的阅读源码，会很痛苦
date: 2024-3-11 13:20:18
categories: nodejs
index_img: /img/node.js_logo..png
math: true
# banner_img: /img/read-code-index.png
---

## 💾 nodejs 内存溢出

在做`设计稿转布局代码`时，采用的任意个数元素形成若干个`组合`的方式来识别布局，由于组合的个数过多，导致内存溢出，程序崩溃。
![内存溢出截图](/img/heap_out_of_memory.jpg)
📊 **-- -- 回顾组合 -- --**

从 $n$ 个不同元素里，取出 $k$ 个元素，不考虑顺序，得到的集合称为 **组合**。

公式：

$$
C(n, k) = \binom{n}{k} = \frac{n!}{k! \cdot (n-k)!}
$$

例子：
从 $[A,B,C]$ 中取 2 个元素的组合是：

- $[A,B]$
- $[A,C]$
- $[B,C]$

所有组合数之和是：

$$
\sum_{k=0}^{n} C(n,k) = 2^n
$$

⚠️ **-- -- 回忆问题 -- --**

如果 n = 39 的话，要生成所有`组合`, 一共有 5497 亿种组合，nodejs 程序依赖 v8 的内存分配，一般默认只有 1G ~ 2G 运行内存，在做 k=33 时，也就是 3,262,623(约 326 万)个组合的时候，内存增长了`1673.96MB`，然后就内存溢出了。

$$
\sum_{k=0}^{n} C(n,k) = 2^n = 549755813888
$$

简单估算一下一个数字型的数组，也就是`number[]`类型数据，占据多少内存。

🔢 **javascript 数字存储方式**

在 JavaScript 中，所有数字都是以 IEEE 754 双精度浮点数(64 位)格式存储的，理论上每个数字占用 `8字节`。
`[ 符号位 1 ] [ 指数 11 ] [ 尾数 52 ]`

> v8 对 SMI (Small Integer) 进行了优化，对于范围在 -2^30 到 2^30-1 之间的整数，SMI 直接存储在指针中，不需要额外的堆内存分配。在 64 位系统上，SMI 占用 8 字节（包含标记位）

📦 **javascript 数组存储方式(Fast SMI Elements)**

> 如果数组里都是 32 位有符号整数（SMI, Small Integer），V8 会直接用紧凑的方式存储这些整数。内存里是 连续的整数存储，几乎等价于 C++ 的 int[]。

存储结构：`arr -> [ 1 | 2 | 3 | 4 ]`
对象头部：约 24-32 字节（包含类型信息、属性映射等）
length 属性：如果是 SMI，不占用额外堆内存
Elements 数组：存储实际元素的连续内存块

假设有一个包含 n 个小整数的密集数组：`const arr = [1, 2, 3, 4, 5];`
内存占用约为：

- 数组对象开销：~32 字节
- 5 个 SMI 整数：5 × 8 字节 = 40 字节
- 总计：~72 字节

🧮 **计算 n=39，k=33 时所有组合的内存大小**
带入所有数字计算：
`(8 * 33 + 32) * 3262623 = 992,637,392B = 969,372 KB = 946.7 MB = 0.92 GB`

也就是单纯这些数字数字，就有接近 1G，在我的程序中还有其他的业务逻辑，内存增长了`1673.96MB`，超出了内存。

## 💡 解决方案

不收集所有组合，每一次生成组合就去执行后续逻辑，而不是把所有组合都放在一个大数组里(`[组合1，组合2，...所有组合]`),再通过遍历的方式去执行后续逻辑。但是这样有有个问题，就是这么多个组合(5497 亿)，这种计算量级，不是一个普通服务器能跑完的，在这个项目中，我用 mac pro(8 核 16G)启动，跑 326 万个组合要 `10分钟`以上。所以也就只能优化算法，没错后面一篇是讲述我优化算法的经历。
