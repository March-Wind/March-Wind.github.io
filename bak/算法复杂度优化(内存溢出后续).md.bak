---
title: 算法复杂度优化(内存溢出后续)
# subtitle: 没有方法的阅读源码，会很痛苦
date: 2025-7-21 17:13:05
categories: nodejs
index_img: /img/algorithm.png
math: true
# banner_img: /img/read-code-index.png
---

## 算法复杂度优化(内存溢出后续)

**-- -- 问题描述 -- --**
在做`设计稿转布局代码`时，采用的任意个数元素形成若干个`组合`的方式来识别布局。在做 k=33 时，也就是 3,262,623(约 326 万)个组合的时候，导致内存溢出了。因为占用内存接近 1G。`(8 * 33 + 32) * 3262623 = 992,637,392B = 969,372 KB = 946.7 MB = 0.92 GB`。虽然可以生成一个组合就执行判断布局，但是要遍历$2^n$个组合，是指数级的复杂度，当 n=39 时， 有 5497 亿种组合，一台 mac pro(8 核 16G)跑 326 万次要 10 分钟以上。所以只能修改算法，目前组合的方式，生成组合的算法是指数级，是无法再日常生产中跑的。

**-- -- 错误中进步 -- --**

1. **思考：** 一开始的思路是在想，不是每个组合都可能形成布局的，也就是有一些组合很明显一定不行形成组合，那么缩小组合的个数，就能降低算法复杂度，不用枚举所有的组合。
2. **发现特征：** 只有相邻的元素才有可能形成组合。把相邻的元素使用链表连起来，其实这种形式在数据结构上叫`工程邻接矩阵`,可以把相邻关系表达为`邻接矩阵`，去遍历每个邻接`路径`就行。记录在四个方向上邻接的节点，然后把关系表达为邻接矩阵。

   ```
   // 链的节点类型
     interface ChainNode {
       value: RelationalLayoutEntity | LayoutBlock;
       block: Block;
       index?: number;
       top: ChainNode[]; // 上方的邻接node
       bottom: ChainNode[]; // 下方的邻接node
       left: ChainNode[]; // 左边的邻接node
       right: ChainNode[]; // 右边的邻接node
     }

   ```

3. **探索邻接矩阵：**
   邻接矩阵，本身是一种图关系，分为好几种：有向图(单向就是一条路径)、无向图(A 和 B 相连，只是一条路径)、连通图(任意两个节点之间都存在路径) 、 非连通图(存在无法到达的节点，图被分为多个连通分量)、完全图(任意两个不同节点都有边连接)、树 (连通的无环无向图，n 个节点有 n-1 条边)、有向无环图(从 A 发出，怎么走都走不到 A)、有向有环图(从 A 绕一圈，还能走到 A).虽然有这么多种，但是遍历方法就一种，只要使用邻接矩阵，那么就一种遍历方法，如下(enumerateAllSimplePaths):
   邻接矩阵：

   ```
     const adjMatrix = [
       // 1  2  3  4  5
       [0, 1, 0, 0, 1], // 1
       [1, 0, 1, 1, 0], // 2
       [0, 1, 0, 0, 0], // 3
       [0, 1, 0, 0, 0], // 4
       [1, 0, 0, 0, 0], // 5
     ];
   ```

   遍历邻接矩阵：

   ```
     function enumerateAllSimplePaths(adjMatrix: number[][]): number[][] {
       const n = adjMatrix.length;
       const results: number[][] = [];
       const visited: boolean[] = new Array(n).fill(false);

       function dfs(current: number, target: number, path: number[]) {
         if (current === target) {
           results.push([...path]);
           return;
         }
         visited[current] = true;
         for (let next = 0; next < n; next++) {
           if (adjMatrix[current][next] === 1 && !visited[next]) {
             path.push(next);
             dfs(next, target, path);
             path.pop();
           }
         }
         visited[current] = false;
       }

       /**
       * 枚举所有 (i, j) 顶点对，i < j 保证不重复
       * i 是起点
       * j 是终点（目标）
       * path 是当前已经走过的路径（起始只有 [i]）
       */
       for (let i = 0; i < n; i++) {
         for (let j = i + 1; j < n; j++) {
           dfs(i, j, [i]);
         }
       }

       return results;
     }
   ```

   这个算法的神奇之处就是对不同的种类的图，得出来的时间复杂度是不一样的，针对有向有环图，时间复杂度普通情况是多项式级别的，最坏的是 n^2 \* 2^n，虽然降低了时间复杂度，但是必然避免不了最欢的情况。所以丢弃了这个方案。同时也探索了 SCC 分治方法等其他枚举算法，时间复杂度也都很高，并且很路径数量是强相关的。

**-- -- 解决方案 -- --**
调整思路，能被放在一起识别布局的，一定是被一个外接矩形框包含的，问题也就转换成只要枚举出所有的`包含任意个数元素矩形框`就行了，枚举出所有的包含矩形框,可以使用计算任意两个元素的外接矩形框，然后去重就行了。时间复杂度也就是 n^2,当然还有其他的条件限制外接矩形能不能成立，最终的时间复杂度是 n^3.下面是伪代码

```
export function enumerateRectangleCombinations(
  entity: Entity // 包含所有宽高信息，以及唯一标识
){

  for (let i = 0; i < entity.length; i++) {
    for (let j = i + 1; j < entity.length; j++) {
      const node1 = entity[i];
      const node2 = entity[j];

      // 计算两个节点形成的矩形边界
      const rectangleBounds = calculateRectangleBounds(node1, node2);

      // 找出完全包含在矩形内的所有节点
      const containedNodes: Entity[] = [];
      const containedIndices: number[] = [];

      for (let k = 0; k < Entity.length; k++) {
        const node = Entity[k];
        if (isNodeContainedInRectangle(node, rectangleBounds)) {
          containedNodes.push(node);
          containedIndices.push(k);
        }
      }

      // 检查矩形能不能成立
      let flag = false;
      for (let k = 0; k < entityOrBlockSet.length; k++) {
        const node = entityOrBlockSet[k];
        if (isNodeIntersectingWithRectangle(node, rectangleBounds)) {
          flag = true;
          break;
        }
      }
    }
  }
}
```

成功将指数级的时间复杂度降到 n^3，撒花。

## 总结

优化算法可以从两个方面入手：1. 通过优化**摆弄**`抽象的实物`的方式来使**摆弄**的次数少；2. 在解决问题上面，减少可能性方案的数量。今天对第 2 条感受很深。
