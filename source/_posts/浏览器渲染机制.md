---
title: 浏览器渲染机制
date: 2023-12-26 18:08:36
tags:
  - 浏览器
categories: 浏览器
index_img: /img/chrome.png
---

### 机制

浏览器按帧(Frame)驱动的渲染机制，一帧时间大概 16.6ms，每隔 16.6ms 屏幕刷新一次，如果有大量计算或者大量节点绘制，超过 16.6ms 时间，就会产生掉帧情况。如果只插入一个简单的 span，肯定不需要 16.6ms 就执行能执行完，但是也要等到下一帧渲染，此时也没有计算布局(Layout 阶段 )，也没有绘制(Paint 阶段)。

一个典型的帧（Frame）大致包括以下阶段：
| 阶段 | 名称 | 是否占用主线程 |
| ---------------- | ------------------------------ | ------- |
| 1️⃣ JS 执行阶段 | 运行脚本，操作 DOM、修改样式 | ✅ 占用 |
| 2️⃣ Style 阶段 | 重新计算 CSS 样式（Recalculate Style） | ✅ 占用 |
| 3️⃣ Layout 阶段 | 重新计算元素几何位置（Reflow / Layout） | ✅ 占用 |
| 4️⃣ Paint 阶段 | 绘制像素信息到图层 | ✅ 占用 |
| 5️⃣ Composite 阶段 | GPU 合成各图层显示 | ✅ 部分并行，可异步 |

当设置 DOM 属性时，浏览器并不会立即去刷新到屏幕上，而是放在渲染队列。等待微任务都结束了，然后调用 requestAnimationFrame 的回调，再去渲染。所以 JS 的同步执行时间不能太长，否则会掉帧。这也是 React 向 Fiber 架构演进的主要原因。下面这个例子的打印顺序可以验证这一点。

```html
<div id="box" style="width: 100px; height: 100px; background: lightcoral">box</div>
<button id="btn">Click</button>
<script>
  const box = document.getElementById("box");
  const btn = document.getElementById("btn");
  function log(msg) {
    console.log(`${performance.now().toFixed(1)}ms: ${msg}`);
  }
  btn.onclick = () => {
    log("1. click handler start");

    // 同步 DOM 修改（不会立即 paint，真正绘制是在第 5 步 requestAnimationFrame 回调之后）
    box.style.width = "300px";
    log("2. DOM modified，but not paint");

    // 一个微任务
    Promise.resolve().then(() => {
      log("4. microtask (Promise.then)");
    });

    // requestAnimationFrame 回调
    requestAnimationFrame(() => {
      log("5. rAF callback (before paint)");
    });

    // 一个宏任务（setTimeout）将排到下一轮，会在浏览器可能已渲染后执行
    setTimeout(() => {
      log("6. setTimeout callback (next macrotask)");
    }, 0);

    log("3. click handler end");
  };
</script>
```

打印结果是：

```
808.2ms: 1. click handler start
808.3ms: 2. DOM modified，but not paint
808.5ms: 3. click handler end
808.5ms: 4. microtask (Promise.then)
809.0ms: 5. rAF callback (before paint)
809.3ms: 6. setTimeout callback (next macrotask)
```

但是访问 DOM 的布局属性会强制浏览器回流（重排），同步计算数值返回，此时并不会触发重绘，也就是只计算了位置，但是没有显示到屏幕上，但是整体布局都要计算一遍，才能得到当前 DOM 的布局属性，所以非常耗时。绘制还是在同步任务和微任务执行完之后，再绘制到屏幕上。下面这个例子可以验证：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="box" style="width: 100px; height: 100px; background: lightblue"></div>
    <button onclick="test()">点击开始测试</button>
  </body>
  <script>
    const box = document.getElementById("box");

    function log(msg) {
      console.log(`${performance.now().toFixed(1)}ms: ${msg}`);
    }

    async function test() {
      log("点击开始测试");

      // 改变样式，但还未渲染
      box.style.width = "300px";
      log("已修改样式 width=300px (尚未渲染)");

      // 强制触发一次重排，但是没有绘制显示到屏幕上，所以不会触发 requestAnimationFrame 回调
      const width = box.offsetWidth;
      log("读取 offsetWidth=" + width + "（触发同步布局计算，但也没有绘制）");

      box.style.height = "200px";
      // 强制触发一次重排，但是没有绘制显示到屏幕上，所以不会触发 requestAnimationFrame 回调
      const height = box.offsetHeight;
      log("读取 offsetHeight=" + height + "（触发同步布局计算，但也没有绘制）");

      // 微任务测试
      Promise.resolve().then(() => {
        log("Promise.then（微任务）执行");
      });

      // 宏任务测试
      setTimeout(() => {
        log("setTimeout（下一个宏任务）执行");
      });

      // 在 rAF 中观察何时被调用
      requestAnimationFrame(() => {
        log("requestAnimationFrame 执行（渲染前）");
      });

      // 模拟主线程卡顿
      const start = performance.now();
      while (performance.now() - start < 50) {} // 占用 50ms
      log("长任务结束（主线程刚空闲）");
    }
  </script>
</html>
```

打印结果：

```paint
1062.0ms: 点击开始测试
1062.2ms: 已修改样式 width=300px (尚未渲染)
1062.3ms: 读取 offsetWidth=300（触发同步布局计算,但也没有绘制）
1062.5ms: 读取 offsetHeight=200（触发同步布局计算，但也没有绘制）
1112.6ms: 长任务结束（主线程刚空闲）
1112.7ms: Promise.then（微任务）执行
1113.1ms: requestAnimationFrame 执行（渲染前）
1113.5ms: setTimeout（下一个宏任务）执行
```

### 加入 event loop 一起看

JavaScript 是单线程，所有的代码都在主线程执行，同时只能执行一个任务，也就是“调用栈”来追踪函数执行的顺序。

- 调用栈是一种数据结构，使用后进先出（LIFO）原理临时存储和管理函数调用
- 调用函数时，会将它放到栈顶。从函数返回时，再把它从栈顶弹出。
  比如 A 函数调用 B 函数，B 函数调用了 C 函数，就是下面的调用栈，先执行 C，再执行 B，最后执行 A。如果有异步任务，就先等同步任务执行完，等待异步任务完成，放入任务队列，再放进调用栈里执行。
  ```paint
  ┌───────────┐
  │   C()     │  ← 正在执行
  ├───────────┤
  │   B()     │
  ├───────────┤
  │   A()     │
  └───────────┘
  ```

> event loop 是浏览器的 event loop，所以从 script 标签开始，script 是一个宏任务。

```paint
    宏任务 --> 微任务 --> 渲染(重排重绘) --> 再执行下一个宏任务
```

🔹 宏任务（MacroTask）
每个宏任务都是一次独立的执行片段，包括：

- script（整体代码）
- setTimeout
- setInterval
- setImmediate（Node）
- I/O（网络请求、文件选择上传：<input type="file">、文件读取：FileReader API 读取本地文件内容、文件保存：触发下载或使用“文件访问 API”、本地存储：localStorage/sessionStorage/indexedDB、Cache API：缓存网络请求响应）

🔹 微任务（MicroTask）

每次宏任务执行完后立即清空，包括：

- Promise.then / catch / finally
- queueMicrotask
- MutationObserver
- process.nextTick（Node 独有）

**完整事件：**

```
┌─────────────────────────────┐
│ 1. 取出下一个宏任务 (task)  │
│ 2. 执行所有同步代码          │
│ 3. 执行所有微任务 (Promise等) │
│ 4. 判断是否需要渲染：         │
│    - 这一帧是否到了 (16.6ms) │
│    - 页面有改动吗？          │
│    - 主线程空闲吗？          │
│ 5. 如果满足，就执行一帧渲染    │
│ 6. 然后进入下一个宏任务循环   │
└─────────────────────────────┘
```
