---
title: React原理
date: 2024-11-03 19:54:06
tags:
  - React
categories: React
index_img: /img/react-logo.png
---

### React Fiber

React 15 之前是 stack Reconciler，也就是从虚拟 DOM 的根节点递归遍历所有节点进行跟旧的节点对比，记录所有差异，进行更新，然后立即执行更改，直到更新完成。但是在大组件树更新的时候，就有长期占据主线程，导致页面响应不了，并且有掉帧。
React 16 开发引入了 Fiber 架构，把比较虚拟 DOM 并记录变更阶段的任务拆分成小任务，然后根据优先级，每执行一小段时间(5ms)，就提交这些更新，交给浏览器先去绘制 DOM、响应用户输入。

#### 辨析

1. React 并没有提高渲染性能，反而降低的渲染性能，因为中间还要对比虚拟 DOM。只是让视图更新更高效、更可维护。高效是声明式 UI 的高效，是开发阶段的高效，不是渲染阶段的高效。
2. 浏览器按帧(Frame)驱动的渲染机制，一帧时间大概 16.6ms，每隔 16.6ms 检查 DOM、样式、布局、绘制，如果一帧内完成所有工作 → 流畅；超过 16ms → 丢帧、卡顿。
   一个典型的帧（Frame）大致包括以下阶段：
   | 阶段 | 名称 | 是否占用主线程 |
   | ---------------- | ------------------------------ | ------- |
   | 1️⃣ JS 执行阶段 | 运行脚本，操作 DOM、修改样式 | ✅ 占用 |
   | 2️⃣ Style 阶段 | 重新计算 CSS 样式（Recalculate Style） | ✅ 占用 |
   | 3️⃣ Layout 阶段 | 重新计算元素几何位置（Reflow / Layout） | ✅ 占用 |
   | 4️⃣ Paint 阶段 | 绘制像素信息到图层 | ✅ 占用 |
   | 5️⃣ Composite 阶段 | GPU 合成各图层显示 | ✅ 部分并行，可异步 |

   如果执行 DOM 操作，增删改产和样式修改，是不会立刻绘制的，先放在渲染队列

包含从 JS 执行到计算布局和样式，最后显示在
